#!/usr/bin/env bash
#
# Functions
#
# @author Charlie Revett

# `asd` outputs all available functions from this file.
asd() {
  echo "> Available bash functions"
  echo "> See: ~/projects/github.com/revett/dotfiles/.functions"

  f=("branch" "copy-files-for-prompt" "find-free-port" "generate-passphrase" "prcake" "prgen-markdown --reviews-channel --silent" "tldr" "tre")
  printf -- '  - %s\n' "${f[@]}"
}

# `branch` is used within a number of aliases, and returns the branch from the current git
# directory. Taken from oh-my-zsh.
# See: https://gist.github.com/DavidToca/3086571
branch() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo ${ref#refs/heads/}
}

# `copy-files-for-prompt` copies the contents of the files passed as arguments to the clipboard, with
# the file names as comments above the contents.
copy-files-for-prompt() {
  output=""

  for file in "$@"; do
    if [[ -f "$file" ]]; then
      output+="File: \`$file\`\n\n\`\`\`\n$(cat "$file")\n\`\`\`\n\n"
    fi
  done

  echo -e "$output" | pbcopy
  echo "Copied to clipboard."
}

# `find-free-port` finds a local port that is not in use
find-free-port() {
  while true; do
    random_port=$(( ((RANDOM<<15)|RANDOM) % 49152 + 10000 ))
    exists="$(nc -z 127.0.0.1 $random_port < /dev/null &>/dev/null; echo $?)"

    if [ "${exists}" != "0" ]; then
      echo $random_port
      return 0
    fi
  done
}

# `generate-passphrase` generates a random passphrase based password.
generate-passphrase() {
  CHUNKS=4
  if [ "$#" -eq 1 ]; then
    CHUNKS=$1
  fi

  gshuf -n$CHUNKS /usr/share/dict/words | tr -s '\n' '-' | sed 's/.$//' | awk '{print tolower($0)}'
}

# Function to approve a GitHub PR with an optional message and a cake emoji.
# Usage:
#   prcake PR_NUMBER ["OPTIONAL_MESSAGE"] [REPO_NAME]
#   If REPO_NAME is not provided or is empty, defaults to "core".
#   If OPTIONAL_MESSAGE is provided, it is added above the cake emoji.
prcake() {
  if ! [[ $1 =~ ^[0-9]+$ ]] || [ $1 -le 0 ]; then
    echo "error: first argument must be a positive integer."
    return 1
  fi

  local message=${2:-""}
  local repo=${3:-core}
  local pr_url="https://github.com/incident-io/$repo/pull/$1"

  if [ -z "$message" ]; then
    gh pr review $pr_url --approve --body ":cake:"
  else
    gh pr review $pr_url --approve --body "$message

:cake:"
  fi
}

# `prgen-markdown` creates a markdown string from details about a GitHub pull request.
# Flags:
#   -s|--silent: Silence output.
#   -r|--reviews-channel: Open the #reviews channel.
prgen-markdown() {
  # Links to Slack channels.
  local team_reviews_channel="slack://channel?team=T01DMDZT3PD&id=C057715CH2R"
  local reviews_channel="slack://channel?team=T01DMDZT3PD&id=C02D0H4J65U"

  # Flags.
  local silent_flag=0
  local reviews_channel_flag=0

  # Check for flags.
  for arg in "$@"; do
    case $arg in
      -s|--silent) # Silence output.
        silent_flag=1
        ;;
      -r|--reviews-channel) # Open the #reviews channel.
        reviews_channel_flag=1
        ;;
    esac
  done

  # Get data from the GitHub API, via the CLI.
  local data=$(gh pr view --json title,url,additions,deletions)
  local additions=$(jq -r '.additions' <<< "$data")
  local deletions=$(jq -r '.deletions' <<< "$data")

  local lines_changed=$(echo "$additions + $deletions" | bc)
  if [ $silent_flag -eq 0 ]; then
    echo "Changes: $lines_changed"
  fi

  # Conditionally choose an emoji based on the number of lines changed.
  local emoji=""
  if [ "$lines_changed" -le 10 ]; then
    emoji=":tardigrade:"
  elif [ "$lines_changed" -le 100 ]; then
    emoji=":bat:"
  elif [ "$lines_changed" -le 250 ]; then
    emoji=":wolf:"
  else
    emoji=":gorilla:"
  fi

  local link="$emoji $(jq -r '"[\(.title)](\(.url))"' <<< "$data" | tr -d '\n') cc/ "

  # Copy to clipboard, and output.
  echo -n "$link" | pbcopy
  if [ $silent_flag -eq 0 ]; then
    echo "Output:  $link"
  fi

  # Decide which Slack channel to open.
  local slack_channel=$([ $reviews_channel_flag -eq 1 ] && echo "$reviews_channel" || echo "$team_reviews_channel")
  open "$slack_channel"
}

# `tldr` wraps chubin/cheat.sh, and will pipe the resulting sheet in to less if it is longer than
# the height of the terminal.
# See: https://github.com/chubin/cheat.sh#usage
tldr() {
  CMD="curl --silent https://cheat.sh/$1"
  QUERY="$(shift 1; IFS="+"; echo "$*")"
  CMD="$CMD/$QUERY"

  echo "$CMD"

  SHEET=$($CMD)
  TERMINAL_LINES=$(tput lines)
  SHEET_LINES=$(echo "$SHEET" | wc -l)

  if [ "$SHEET_LINES" -gt "$TERMINAL_LINES" ]; then
    echo "$SHEET" | less -R
    return 0
  fi

  echo "$SHEET"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring the `.git`
# directory, listing directories first. The output gets piped into `less` with options to preserve
# color and line numbers, unless the output is small enough for one screen.
tre() {
  tree -aC -I '.git|node_modules|.cache' --dirsfirst "$@" | less -FRNX;
}
